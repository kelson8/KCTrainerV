import re

def parse_native_signature(signature_line):
    # Example line: static int START_NEW_SCRIPT(const char* scriptName, int stackSize) { return invoke<int>(0xE81651AD79516E48, scriptName, stackSize); } // 0xE81651AD79516E48 0x3F166D0E b323

    # Regex to capture return type (Group 1), native name (Group 2), and arguments (Group 3)
    # The 'static' is optional here as it might be removed by now depending on exact format
    match = re.search(r'(?:static\s+)?([\w\s<>,&*]+?)\s+(\w+)\s*\((.*?)\)(?:\s*{[^}]*}|;)\s*//\s*(0x[0-9A-Fa-f]+)', signature_line)

    if not match:
        return None, None, None, None # Return None if parsing fails

    return_type_str = match.group(1).strip()
    native_name = match.group(2).strip()
    args_str = match.group(3).strip()
    native_hash = match.group(4).strip()

    # Special handling for void return types (e.g., if it's empty or 'void')
    if return_type_str.lower() == 'void':
        return_type_str = 'void' # Standardize to 'void'

    # Parse arguments - this is tricky due to default args, pointer types, etc.
    # For now, we'll keep it simple by splitting by comma, but a full C++ parser would be needed for perfect accuracy.
    args_list = []
    if args_str:
        # A more robust arg parsing might be needed for complex types like "const char*", "Any*", etc.
        # For simplicity, we're just extracting the type name before the variable name.
        raw_args = args_str.split(',')
        for arg in raw_args:
            arg_stripped = arg.strip()
            if ' ' in arg_stripped: # Look for a space between type and name
                arg_type = arg_stripped.split(' ')[0].strip()
            else: # Single word type (e.g., "int", "bool")
                arg_type = arg_stripped
            args_list.append(arg_type) # Store the type string

    return native_name, native_hash, return_type_str, args_list


def generate_native_bindings_cpp(natives_h_path, output_cpp_path):
    # Regex to capture the full native line for detailed parsing
    native_line_pattern = re.compile(r'static (?:[\w\s<>,&*]+?\s+)?([\w_]+)\s*\([^;]*\)(?: {[^}]*}|;)\s*// (0x[0-9A-Fa-f]+)')

    native_info = [] # List of (name, hash, return_type_str, arg_type_list)

    try:
        with open(natives_h_path, 'r', encoding='utf-8') as f:
            for line in f:
                # First, ensure it's a native declaration line
                if native_line_pattern.search(line):
                    name, hash_val, return_type, args_types = parse_native_signature(line)
                    if name: # If parsing was successful
                        native_info.append((name, hash_val, return_type, args_types))
    except FileNotFoundError:
        print(f"Error: {natives_h_path} not found.")
        return

    # Generate the C++ binding code
    with open(output_cpp_path, 'w', encoding='utf-8') as f:
        f.write('// This file was automatically generated by a script.\n')
        f.write('// Do not modify manually.\n\n')
        f.write('#include "LuaManager.h"\n') # Your LuaManager header
        f.write('#include "LuaNatives.h"\n') # If you put GetNativeHashByName here
        f.write('#include <sol/sol.hpp>\n')
        f.write('#include <cstdint>\n')
        f.write('#include <string>\n')
        f.write('#include <type_traits>\n\n') # For std::is_same_v etc.
        f.write('#include <inc/types.h>') # For Vector3 and other items.

        f.write('// Forward declare LuaInvokeInternal (assuming it\'s in LuaManager.cpp)\n')
        f.write('template <typename R, typename... Args>\n')
        f.write('sol::object LuaInvokeInternal(const sol::environment& env, uint64_t nativeHash, Args&&... args);\n\n')

        # Generate a helper to map string types to actual C++ types for return
        f.write('template<typename T> struct ReturnTypeTrait { using type = T; };\n')
        f.write('template<> struct ReturnTypeTrait<void> { using type = void; };\n')
        f.write('template<> struct ReturnTypeTrait<int> { using type = int; };\n')
        f.write('template<> struct ReturnTypeTrait<float> { using type = float; };\n')
        f.write('template<> struct ReturnTypeTrait<bool> { using type = bool; };\n')
        f.write('template<> struct ReturnTypeTrait<const char*> { using type = const char*; };\n')
        f.write('template<> struct ReturnTypeTrait<char*> { using type = char*; };\n') # If char* is a return type
        f.write('template<> struct ReturnTypeTrait<Any*> { using type = Any*; };\n') # If Any* is a return type
        f.write('template<> struct ReturnTypeTrait<unsigned int> { using type = unsigned int; };\n') # For uint
        f.write('template<> struct ReturnTypeTrait<Vector3> { using type = LuaVector3; };\n') # Map Vector3 from natives.h to your LuaVector3
        f.write('// Add more mappings as needed for complex return types (e.g., Ped, Vehicle, Hash, etc.)\n\n')


        f.write('void LuaManager::BindAllNativesToLua() {\n')
        f.write('    auto& luaState = GetLuaState();\n\n')

        for name, hash_val, return_type_str, arg_types in native_info:
            # Skip the custom WAIT if you're binding scriptWait separately
            if name == "WAIT":
                f.write(f'    // Skipping custom WAIT native (bound via SCRIPT_WAIT or similar)\n')
                continue

            # Construct the lambda arguments
            lambda_args_str = ""
            if arg_types:
                # Lua variadic args for flexibility, sol handles conversions
                lambda_args_str = "sol::variadic_args args"

            # Determine the C++ return type for the templated LuaInvokeInternal
            cpp_return_type = return_type_str
            if return_type_str == "Vector3": # Map from natives.h type to your Sol type
                cpp_return_type = "LuaVector3"
            elif return_type_str == "Any*": # Map from natives.h type to your Sol type
                cpp_return_type = "Any*" # Or whatever Sol type matches Any*

            f.write(f'    luaState["{name}"] = [](const sol::this_environment& curEnv, {lambda_args_str}) {{\n')
            f.write(f'        return LuaInvokeInternal<{cpp_return_type}>(curEnv, {hash_val}ULL, args);\n')
            f.write(f'    }};\n')

        f.write('}\n')

    print(f"Successfully generated {len(native_info)} native binding entries to {output_cpp_path}")

# --- How to use ---
if __name__ == "__main__":
    NATIVES_H_FILE = 'natives.h' # **UPDATE THIS PATH**
    OUTPUT_CPP_FILE = 'GeneratedLuaNativeBindings.cpp'

    generate_native_bindings_cpp(NATIVES_H_FILE, OUTPUT_CPP_FILE)